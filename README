Priorité 1.0: Je dois avoir une très bonne raison avant de faire ce changement!

Instead of Table, simplement overloader les methods avec les arguments différents.
Déplacer le getTableName dans le model.
Vive les templates.
Global variable DB.
Objectif: Imiter rails.
https://stackoverflow.com/questions/4665117/c-virtual-function-return-type
is a vector<Model&> covariant with a vector<Jar&>?
class Model {
  virtual static string getTableName();
  static vector<Model> all() {
    DB.load()
  }
}
class Jar : public Model {
  static string getTableName() {return "jars";}
};
Si je veux du caching, implémenter MyCollection<T>, au lieu de vector<T>


Prendre le numéro de pot du DetectedHRCode et that's it.
Trouver le jar avec cette id là.
Pickup this jar.
Store this jar.

bon Colonne:

for colonne in colonnes:

  if (colonne.jar_format_id != jar.jar_format_id) {continue;}

  etagere = colonne.etagere
  nb_spots = shelf.depth / colonne.width;
  nb_spots = colonne.locations.size;
  if (nb_occupied < nb_spots) {
    location = createLocation();
  }
end

colonne = createColonne();    
location = createLocation();

Purée de courge à l'érable
Tofu général tao
Tofu magique selon Loonie

Les petits pots, comme les pots à épices sont soulevé par dessus les autres. Les gros pots, ah peut-être seulement sur
la tablette du bas! pour safety! sont différents

Là je m'occupe des petits pots soulever par le dessus n'importe où. Hypothèse, les petits pots ont tous la même grandeur à peu près dans une même tablette.
Ranger dans des colonnes de même largeur.

Exemple:

J'ai déjà:
- 4 petit plein qui forme une première colonne pleine
- 1 petit pot large dans une 2e colonne (peut avoir un 2e)
- 1 petit pot dans une 3e colonne

Je détecte:
- 2 petit pots
- 3 petit pot large

Prendre les pots détecter un par un (en commançant par le plus haut)
Voir s'il y a déjà des colonnes dans lequel il pourrait rentrer.
Sinon créer une nouvelle colonne et le ranger dedans.

Donc créer une modèle colonne.

Garder le modèle Location, mais il n'est pas généré au départ parce que tu ne sais pas quelle
grandeur de pot que tu vas insérer.

Utiliser le mot français colonne pour la table pour ne pas que ce soit confu avec columns in a database.

Ajouter colonne_id to locations??? Sure whatever de toute façon il n'y en aura jamais beaucoup.

Les coordonées polaires et les coordonées cartésiennes sont vraiment différentes.

Les coordonées polaire:
X: X0 est à la droite du point de vue de l'utilisateur. C'est le maximum que le bras peut se déplacer.
Y: Y0 est le plus bas que la machine peut se déplacer
T: Theta0 est le bras orienté vers la gauche du point de vue de l'utilisateur.

Les coordonnées cartésiennes:
X: X0 est à partir de la paroie gauche.
Y: Y0 est la tablette la plus basse.
Z: Z0 est à partir du devant.

// TO print all exceptions
    } catch(...) {
      std::exception_ptr p = std::current_exception();
      std::clog <<(p ? p.__cxa_exception_type()->name() : "null") << std::endl;
      response->write("Error an exception occured.");
    }

MODELS:

Ingredient: name, fdc_id

DIRECTORIES:

src/: Directly in src are executable source files
src/utils: Code with no dependencies
src/lib:   Code with dependencies (e.g. Dependency on std so arduino cannot use it)
src/core:  Code and models that are specific to my application
src/arduino: Arduino files
src/config/: Config files

BALAYAGE:

Le bras robotique balais le comptoir et balais les tablettes si les portes on été ouvertes afin
de déterminer la nouvelle position des pots.

Lorsqu'il détecte un pot, il demande la position du bras. Par la position du bras et la position du pot dans l'image
la position du pot est déterminée.

Il garde alors en mémoire les positions des pots détectés et une image par pot. Ce sont des HRCodePositionObject.

(Peut-être 2 images pour mieux déterminer la position.)

Ensuite, les codes sont analyser et devienne des HRCodeObject.

MODELS:

lib/hr_code => HRCode(croppedImage,x,y,scale)
core/sweep => DetectedHRCode(HRCode, toolPosition, angle)
core/jar_position_analyzer => PositionedHRCode(HRCode, jarPosition) => writes unique jar images to disk
core/jar_parser => JarLabel(position, number, weight, contentName, contentId)

----

DESIGN:

Je veux pouvoir rajouter des extensions sur les côtés. Alors au lieu de faire des cables fixes sur des roulettes,
faire un genre d'assenseur, et quand la machine est en haut ou en bas, la machine peut se déplacer gauche droite
et sortir de son extension pour aller dans un autre.


----

UTOPIE:

Avec la machine, idéalement plus besoin de frigo. La nourriture est fait pour la quantité que tu manges. Tous les ingrédients sont sec et déshydratées.
Le problème peut-être est que fais tu des restants de nourriture qui ne se conserve pas? Il ne devrait pas y en avoir. Et pour combler la faim, tu
manges du dessert. Le dessert peut rester à température pièce sans problème.

----

Ca serait pas pire je crois si les templates en c++ tu remplacerait le type de base. Ca veut dire que tu peux implementer un type qui conviendrait pour la fonction.
Et tu overwrite le type qui existe deja. Tu pourrais ainsi patcher pas mal les fonctions. Idée farfelu de même.

----

Charge maximale: 2 kg (un grand pot rempli d'eau)

Vitesse: 1 ft/sec == 30 cm/s

Le voyagement est de 4 ft. Donc 48 po.

Pour un enrouleur de 1 po de diamètre. Ça fais 3 po par tour.
48/3 = 16 tour donc un po de long pour l'enrouleur. (Câble d'acier 1/16) plus un petit peu de safety et pour commencer au moins 3-5 tours toujours.

3 po par tour, donc il faut 4 tour minutes.

Mon moteur doit être capable de au moins soulever 10 lb, gros minimum. Ça serait bien 20 lb.

Mon moteur a un angle de 1.8 degree, donc 200 step. A 1000 rpm comme vitesse moyenne en general pour un stepper, ca fais 200 000 step par minutes. Soit 3333 step par seconde. Donc 3.33 step par millisecond, donc 1 step à tous les 300 microsecondes.

1000 rpm, c'est 16.67 rotations par secondes...

Ah c'est le TB6600 qui fuck les affaires en rajoutant des microsteps!!!

https://www.thingiverse.com/thing:321077/comments

Motor wiring:
https://www.orientalmotor.com/stepper-motors/technology/unipolar-bipolar-connections.html

Cable drums.

Un tour de plus pour que le cable reste en tension.

A typical drum has a 4" diameter which means that each full wind (4 quarter turns) will give about 12.5 inches of lift height. Usually about 1 extra wind is added so the cable stays in tension. You should end up using about 7.5 to 8 turns for a 7' door and about 1 additional turn for an 8' door.

Mon déplacement est de 60" - à peu près 10" (la hauteur de roue à roue). Donc 50" de déplacement.

Mon diamètre de drum est de 1.25" - 1/16" = 1.1875"
1.1875" * PI = 3.73"

50" / 3.73" = 13.4

Un tour de plus est rajouter pour maintenir de la tension.

Donc 14.5 tour.

Pour l'instant, le poids est de 2.5 kg. Il reste risque d'être de 4-5 kg sans charge.

Après un angle de 360 degrés * 14.5 = 5220 degrés, il doit exercé pouvoir soulever une charge de 4 kg.

Une force de 4 kg (8.82 lbs) est appliqué sur le drum à 0.59375" (rayon du drum). Donc un moment de 5.24 lb*po doit être engendré par le ressort après 5220 degrés (91.1 radians).

Mon drum est de 

Double torsion springs can be used when twice the force is required or when you need an even distribution of torque

Torsion springs should be deflected in the direction that closes the coils

Aimants avec ce que l'ingrédient est dessus mes pots.

https://addison-electronique.com/produits/filage/fils-et-accessoires/terminaux-borniers-et-connecteurs/

Acheter bande d'acier (strapping).
Acheter tôle.
Acheter marettes plus petites.
Acheter #8-32 X 0.75"
Acheter #10-24
Acheter petite quicaillerie, ecrous #6-32
Acheter tige filetee 0.25"
Acheter melamine
Acheter caoutchouc établi
Acheter split pin
Ca pourrait comme être des sapin de plastique comme pour les tiroirs pour séparer les pots dans des rangées.
Nut de nylon pour pince haut bas?
Acheter circlip?
Acheter acier 1/4" pour fabriquer coupling male
Acheter standoff pour electronique
Acheter Tube carré 1/2.

TODO: Un test de résistance du truc pour tenir les cables.
Spécifier la charge maximale.

https://medium.com/@machadogj/arduino-and-node-js-via-serial-port-bcf9691fab6a

Un cable drum avec un centre hexagonal pour pouvoir etre entrainer pour tourner tout en pouvant se deplacer, comme ca ca suivrait le cable en meme temps.

La machine serait toujours genre 40" de large, mais tu peux mettre une extension à côté. Ça peut être une extension qui stock seulement des pots (un grand caroussel) ou bien une extension avec un four, ou une extension avec un frigo, ou une extension avec un congélateur, etc... Ils se passent les pots par une porte de côté.

Le matin, le robot pourrait aller chercher tout les pots de déjeuder et les mettre à porté de main pour le monde!

Pour les steppers les fils, je ne comprends pas pourquoi il est si gros le controlleur. Il devrait etre petit et etre directement sur le moteur ou a cote. Il devrait se rendre moins de fil.

2 fils:
0,0 -> STATE 1
0,1 -> STATE 2
1,0 -> STATE 3
1,1 -> STATE 4

POWER et GROUND sont partages pour tous.

Ça serait vraiment malade si le robot était capable d'écrire ses propres étiquettes, quand tu as un nouveau pot et tu veux mettre un nouvel ingrédients, tu mets le pot vide. Il va le peser, inscrire le poids dessus, te demander ce que tu veux mettre dedans, inscrire le code et le nom. Ça serait malade!!!!!

J'aimerais que ma machine possède un outil probe pour les distances. Elle pourrait ainsi déterminé ses propres limites.

C'est mieux des steppers pour les axes de positionnement parce que ça garde la position. (Pas besoin de freins)

Tu peux seulement avoir un certain angle quand tu es à droite ou à gauche? Ça serait plus simple?


<!-- SECTION *Design -->
<div id="design">
<pre>
Section transversale debout ou couchée:

Je dois avec de l'espace derrière pour que ça monte et descende, donc debout c'est mieux pour ça?

Aussi je dois avoir de l'espace pour le moteur et tout.

La hauteur du meuble est de 79" pour pouvoir se déménager facilement (une porte standard mesure 80"). Une section du haut pour la machine est vissée par dessus, et toute la machine s'enlève simplement en la soulevant en haut (Ça pourrait être par en bas aussi).

Pour l'instant, je fais une seule rotation parce que j'ai aussi mon déplacement gauche droite. Peut-être par contre que je vais aussi rajouter une 2e rotation (comme pour un robot SCARA). Pour avoir plus de mobilité. Aussi, ce qui pourrait être cool, c'est d'avoir un 2e bras. Donc 2 bras avec 2 rotations chacune comme ça ils peuvent se déplacer chacun indépendemment l'un de l'autre. C'est donc le torse qui se déplacerait gauche droite pour des armoire larges. Ce déplacement ne serait donc peut-être pas nécessaire pour une petite armoire (le torse toujours au milieu)

Je ne suis pas sûr de faire ça parce que là ça devient vraiment compliqué. Il faut que je rajoute tous les moments doublés. Par exemple, je ne peux plus utiliser un seul monter descendre. Il en faut un pour chaque bras. Pas sûr finalment...

C'est mieux si c'est le bras qui monte et descends et non seulement la tablette mobile pour plusieurs raisons. Premièrement, le bras doit pouvoir monter et descendre pour prendre des pots. Aussi, ça voudrait dire qu'il pourrait utiliser la tablette mobile comme surface de travail.

Il va y avoir une camera sur le robot pour determiner la position des pots. Il va pouvoir trouver la position en x et z. Aussi, il va pouvoir determiner la hauteur des pots. Ainsi, le bras va se positionner au dessus en x et z. Ensuite il va descendre dessus.

Il va y avoir un gros ressort au bout pour donner une marche de manoeuvre sur la hauteur.

Avec la camera sur mon robot, peut-etre que le raspeberry pi devrait etre sur l'ordinateur.

Il n'y a pas le choix, il y a de l'impreicision dans mon systeme. Il y a plusieurs solutions possibles. Des encodeurs pour s'assurer que je ne manque pas de step. Des capteur de force pour arreter a temps, mais je crois que le plus simple et le moins dispendieux serait de simplement donner du lousse a tous les axes avec des ressorts. Je crois que je n'ai pas besoin de haute precision et c'est plus safe ainsi au lieu d'un bras rigide. Ca me prendrait une genre de clutch a ressort sur les gears. Ou peut-etre bien avec une bille et un ressort, ca serait un limiteur de couple. Ca serait rigide sauf si c'est un trop gros contant, et idealement je detecte si le contact n'est plus la donc je sais qu'il a assez force.
</pre>
</div>

<!-- SECTION *Notes -->
<div id="Notes">

<h1>Notes</h1>

NOTE de design:

Mettre mon site de machine beau.

Oui ça serait cool un bras robotique, mais je mets de côté pour l'instant. Tellement de monde ont essayer d'en faire, je n'arriverai jamais à faire mieux pour moins cher. C'est plus cool, mais aussi c'est moins efficace. Parce qu'il n'y a pas de support, c'est beaucoup plus difficile pour les moteurs. Des mouvements linéaires sont beaucoup plus efficaces parce que le déplacement se fait sur des roues.

Toutefois, ce n'est pas en vaint, j'ai une bonne idée je crois. Le potentiel est dans des trucs imbriqués (comme des poupées russes!) C'est beaucoup plus éléguant qu'une structure pleine avec un petit déplacement.
</div>

Speach de vente: Je vais vous compter une histoire. Dire quelque chose de dramatique. Et là c'est là que j'ai su que je devais fabriquer ma machine. Un allier dans la salle dit: Est-ce que c'est vrai cette histoire: Moi de rétortorquer, non, mais ça aurait pu l'être. hahahaha

Fuck l'obscellescence programmé. Fuck les machines à pain qui ne dure pas.

.vimrc

filetype plugin indent on
" On pressing tab, insert 2 spaces
set expandtab
" show existing tab with 2 spaces width
set tabstop=2
set softtabstop=2
" when indenting with '>', use 2 spaces width
set shiftwidth=2


Jig pour plier l'acier:
Faire comme ma petite sandwich plieuse de rebord, mais en super long. Mais bon cela ça serait plus tard?

La jig que ça prendrait c'est avec deux rouleaux peut-être, un creux v et un boss v.

Je tiens à ce que la boite électronique soit à part du robot. C'est le plus clean. Soit une boite en dessous. Sois une boite au dessus.
La seule chose chiante est le câble USB pour la caméra... Il faut que je convertisse USB en ethernet probablement.


Si le cable tray en avant pose, problème, simplement faire un 180 à la machine pour qu'il se retrouve à l'arrière.

Aye, peux être faire un petit rack sur le côté que Heda va se déposer dedans quand il a terminé son boulot. Ça serait ça son home.
Il y aurait simplement besoin de un seul capteur pour valider que Heda est dans son home. Mécaniquement, il saurait précisemment où
il se situe par rapport à ses axes (un tapper pour guider). Si jamais il manque d'électricité, l'utilisateur devra prendre le bras
manuellement et l'emporter justqu'à sa maison.
Avantages: Moins de limit switch (moins de câble électrique), référencement de l'axe thêta aussi. Safe de ne pas faire de référencement n'importe où et briser quoi que ce soit.
Inconvénients: Moins grande précision probablement parce que ne prends pas en compte le backlash.


Idéalement, pour installer le robot, prendre une armoire existante (ou une acheter par le client), défaire
la paroie du fond, installer mes côtés, installer la machine et réinstaller la paroi du fond après ma machine.


Une pince comme un peigne pour soulever les pots lourds.

DCMotor avec un encodeur pour l'axe vertical. Comme ça je vais pouvoir à côté les pots sur les tablettes?

Use interupts to read rotary encoder.
https://playground.arduino.cc/Main/RotaryEncoders/

Upload with a single command to the arduino the new code with the arduino-cli:
https://blog.arduino.cc/2018/08/24/announcing-the-arduino-command-line-interface-cli/
https://arduino.github.io/arduino-cli/getting-started/
